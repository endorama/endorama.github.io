<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>comparison on Edoardo Tenani</title><link>https://endorama.dev/tags/comparison/</link><description>Recent content in comparison on Edoardo Tenani</description><generator>Hugo -- gohugo.io</generator><language>en-gb</language><copyright>Â© Edoardo Tenani 2022 - Some Rights Reserved</copyright><lastBuildDate>Thu, 10 Nov 2022 22:48:03 +0100</lastBuildDate><atom:link href="https://endorama.dev/tags/comparison/index.xml" rel="self" type="application/rss+xml"/><item><title>Golang string comparison benchmark</title><link>https://endorama.dev/2022/golang-string-comparison-benchmark/</link><pubDate>Thu, 10 Nov 2022 22:48:03 +0100</pubDate><guid>https://endorama.dev/2022/golang-string-comparison-benchmark/</guid><description>I recently read No Safe Efficient Ways to Do Three-way String Comparisons in Go - Go 101 Blog about performing string comparisons and some performances issue that the strings.Compare function has.
The main statement of the post is
Benchmark code constantly shows strings.Compare uses 2x CPU time of bytes.Compare when comparing unequal same-length byte sequences (we view both strings and byte slices as byte sequences here).
It got me curious so I jumped to the editor to check what was happening.</description></item></channel></rss>